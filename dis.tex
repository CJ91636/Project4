\pdfoutput=1

\documentclass{l4proj}
\usepackage{listings}
\usepackage{amsmath}%
\usepackage{MnSymbol}%
\usepackage{wasysym}%
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{graphicx}
\usepackage{inconsolata}

%
% put any packages here
%




\begin{document}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{blue}{rgb}{0.12, 0.12, 0.82}
\definecolor{forrestgreen}{rgb}{0.12, 0.52, 0.12}


\lstdefinelanguage{JavaScript}{
  keywords={module, player, endmodule, endplayer},
  morecomment=[l]{//},
  morestring=[s]{\[r}{\]},
  morestring=[s]{\[s}{\]},
  morestring=[s]{\[b}{\]},
  morestring=[s]{\[p}{\]},
  morestring=[s]{\[f}{\]},
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{black}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{forrestgreen}\ttfamily,
  stringstyle=\color{blue}\bfseries,
  sensitive=true
}
\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Modelling and Analysing Contract Signing Protocols}
\author{Christopher James, 1003019J}
\date{March, 2014}
\maketitle

\begin{abstract}
The PRISM probabilistic model checker \cite{Pri}, is a tool for the modelling and analysis of systems. It allows systems to be mathematically assessed in terms of probabilities and outcomes, and can be used to prove the validity of a system based on non-determinism. \\
Contract Signing Protocols [CSP] are used as a measure to ensure that when swapping information on a network, all parties receive what they aim to, with no parties being able to achieve their goals only. In many types of CSP, the parties send bit by bit to each other in turn, until both have the others contract. In case of foul play, a Trusted Third Party [TTP] can be involved, which has the power to grant a particular party their desired contract, or reject this request. \\
The aim of this project is to model and analyse a certain CSP, using PRISM. After analysis, improvements may be suggested if found.
\end{abstract}

\educationalconsent
%
%NOTE: if you include the educationalconsent (above) and your project is graded an A then
%      it may be entered in the CS Hall of Fame
%
\tableofcontents
%==============================================================================

\chapter{Introduction}
\pagenumbering{arabic}
With the rise of connected technologies and networks, there has also been a rise in the number of transactions that now take place digitally. These can involve multiple parties exchanging information they require from one another, however how can these parties trust each other to be honest in the exchange? Many potential solutions have been put forwards, but due to the nature and style of interaction between parties, it can be difficult to map and assess how effective these solutions are. One class of protocols are contract-signing protocols (CSPs), designed to ensure fairness for all parties involved.\\
Consider an exchange of goods over the Internet. Commercial sales are made on-line regularly, but neither party wants to be the only one to commit. The buyer doesn't want to promise to pay until the seller promises to send them the desired goods, and vice versa. Neither party wants to commit first; one solution is to use a contract signing protocol.

CSPs focus on users sending a “contract” to each other; that is, information which needs to be sent in its entirety to bear any use to the party. The idea is that all parties share their information fairly with one another, and each party knows what to expect. There are different approaches to this, and many protocols such as those of Rabin's \cite{rabin1983transaction}, and Ben-Or Goldreich Micalu and Rivest's \cite{ben1990fair}, have been put forward and can be used as solutions. But what is fairness? Here, fairness is treated as a boolean condition; a transaction is considered unfair if any parties can achieve their goal of gaining another parties offer whilst guaranteeing that other parties cannot achieve their desired contract. 
Non-repudiation is another key concept with CSPs.
Non-repudiation, introduced in \cite{jamroga2012fairness}, is the concept that parties who are participating in an exchange cannot deny their taking part; there is ample evidence to show whether they have or have not taken part. This brings with it the concept of a trusted-third party (TTP), an impartial party capable of ensuring fairness in the protocol. Parties can interact with the TTP in one of two ways; one option is that all transactions between the parties can involve the TTP directly, and these protocols are known as non-optimistic. The other, arguably more preferable solution, is to have the parties only contact the TTP as and when it is needed; these types of protocol are known as optimistic. This type of interaction with the TTP means that the TTP can be used for more than one protocol instance at a time, rather than requiring a dedicate third party for each exchange.

There is a need to verify the correctness of these theoretical protocols; many of them are simply too complex to exhaustively simulate, and mathematical proofs cannot always account for all types of interactions. Model checking allows formal analysis of a system, providing a way to obtain quantifiable information about it. It is here that model checking proves useful; being able to create a model to represent the behaviour of such protocols would allow certain checks and properties to be assessed, without the need for exhaustive manual simulation or laborious mathematical proofs.

When attempting to model real world interaction, there is one field which can be both difficult to model and is required to be implemented to keep the model representative of the interactions that can take place, and that is non-determinism. To successfully model a system that models a CSP fully, a tool must be selected that can handle the mathematical aspects of the protocol, such as non-determinism and probability. For this project, PRISM has been selected as the model checking tool, with a section later in the paper with the reasoning and a brief explanation of how PRISM handles the different types of models used in the remainder of the paper.


The following sections make up the rest of the report:
\begin{description}
\item[Chapter 2] looks at the necessary background understanding for the project; Discrete Time Markov Chains, Markov Decision Processes and Stochastic Multi-player Games are all discussed and their use is rationalised. This chapter also examines probabilistic model checking, as well as explaining the tool of choice for this project, the PRISM model checker.

\item[Chapter 3] examines the protocol itself, focusing on elements such as corruptness, honesty and the key property. Other contract signing protocols are also briefly described, introducing such concepts as non-repudiation and optimistic contract signing protocols.

\item[Chapters 4 to 6] focus on the construction of the models and in turn their analysis. Each chapter looks at a different style of modelling, and features the results from the analysis as well as justification for any model development.

\item[Chapter 7] is the conclusion of the project, summarising findings, limitations of the projects and potential future areas of work concerning this specific protocol.
\end{description}


\chapter{Background}
This section discusses the different types of models required to model the system; DTMCs, MDPs and SMGs. This chapter will also explore model checking and the tool of choice for this project, the PRISM model checker \cite{Pri}.

\section{DTMCs}
Discrete-time markov chains [DTMCs] are often used as a way to model probabilistic systems, as discussed by BLAH in \cite{}. They map out a series of states and the probabilities of traversing to other states in the model, which allows the calculation of the probability of achieving a particular goal state from an identified start state. The transitions are directed, and probabilities outgoing from each state must add up to one. Figure \ref{dtmc} below is a simple example, showing how DTMCs can be used to model a coin toss.

\begin{figure}[h!]
\centering
\includegraphics[width=100mm]{images/DTMCExample.png}
\caption{An example of a DTMC showing a coin toss}
\label{dtmc}
\end{figure}

The diagram in figure \ref{dtmc} shows how a series of states can be using to represent a coin toss as a DTMC. The states are labelled to represent the current interaction with the coin; that is to say it's either being flipped, or its displaying a ``heads'' or ``tails'' result. The arrows represent the possibility of a transition from that state to another state, and are labelled with a number representing a probability. These are the probabilities that the state will select this transition.\\
Here, there are only arrows between states that can reach one another. This means that there is no arrow from ``heads'' to ``tails''. as the coin must be flipped again to achieve a different result. However it would also be equivalent to have arrows from every state to every other state, with appropriate probabilities of that transition being set to zero.
A DTMC can also be represented as a tuple $(S, S{_0}, P, L)$, where:
\begin{itemize}
\item{$S$ is the set of possible states}
\item{$S{_0}$ is the initial state}
\item{$P : S \times S \rightarrow [0,1]$ is the probability transition matrix}
\item{$L : S \rightarrow 2^{AP}$ is the set of state labels}
\end{itemize}

The diagram at Figure \ref{dtmc} describes a DTMC, which means it can be represented as a tuple. This DTMC would be represented as a tuple  as:
\begin{itemize}
\item{$S$ is the set of possible states $\lbrace S_0, S_1, S_2, S_3 \rbrace $}
\item{$S{_0}$ is the initial state}
\item{$P : S \times S \rightarrow [0,1]$ is the probability transition matrix $\begin{bmatrix}
0 & 0.5 & 0.5\\ 
1 & 0 & 0\\ 
1 & 0 & 0
\end{bmatrix}$}
\item{$L : S \rightarrow 2^{AP}$ is the set of state labels $L_{(S_0)}=\lbrace Flip \rbrace , L_{(S_1)}=\lbrace Heads \rbrace , L_{(S_2)}=\lbrace Tails \rbrace$}
\end{itemize}

The chain's express possible movements in discrete-time. That is to say for each time unit that occurs, a transition will happen from the current state to an adjacent states; which state the transition is performed with is determined by the probabilities denoted in the matrix. Note here how the probabilities for all transitions from a given state add up to 1; this is because a transition must occur, even if it is from the state back to itself again. 


\section{MDPs}


Markov Decision Processes [MDPs] \cite{puterman2009markov} are similar to DTMCs. They both feature states that can be traversed by given connections; they can also feature probabilities for certain transitions to take place when on any given state. They differ in the respect that in a MDP, choices are not made solely on the probability. An element of non-determinism is brought into the fold, allowing MDP models to make choices, rather than being forced to take a particular solution with a particular probability. This is beneficial as it allows the modelling of real world interaction; when modelling something such as a contract signing protocol, it's not possible to model the probability of one party leaving the contract early as this would be a choice, rather than an outcome based on any type of probability.

\begin{figure}[h!]
\centering
\includegraphics[width=120mm]{images/mdpExample.png}
\caption{An example of a MDP showing the choice between flipping two coins}
\label{mdp}
\end{figure}

The diagram at figure \ref{mdp} shows an extended version of the coin flipping example expressed as a DTMC model in figure \ref{dtmc}. Here, there are two coins that can be flipped; one a standard coin with the usual probabilities, and one a ``biased'' coin that has a higher probability of achieving a ``Head'' result than a ``Tails'' one. The other difference here is that there is a choice between which coin is going to be flipped, the selections being noted by $a$ and $b$ on the diagram. As the choice is non-deterministic, there is nothing to indicate which coin will be selected, so a choice must be made. This interaction reflects a real world choice; the choice between two coins on a table is non-deterministic. For this to be fully the case, the biased coin would have to give the appearance of a normal coin. This is the value that expanding to an MDP model brings, the ability to make a choice between multiple options.\\ 
The transitions leaving the $S_0$ do not have sum to an overall probability of 1; this represents the differences between an MDP and DTMC quite well. There is nothing to suggest which path will be selected, choice $a$ has no impact on choice $b$. The transitions leaving the biased coin state, $S_2$, do sum up to 1 as one of these paths will be selected, however the probabilities of $0.8$ and $0.2$ are used due to the coin being biased towards a ``Heads'' result.


%Again, MDPs can can be represented in a similar fashion as DTMCs as a set of labels, possible states, starting state and a transtition matrix. The majority of these are equivalent to the versions expressed for a DTMC, however the transition probability matric has a notable difference. Below is the transition probability matrix for the MDP in figure \ref{mdp}.\\


%Note here how the property of state transitions horizontally equalling one is no longer applicable. The first row of the matrix sums to equal $a+b$; this is due to the introduction of real choice. It i s a non-deterministic decision that determines the transition from the first state, rather than probability being the deciding factor.


\section{SMGs}


Stochastic multiplayer games [SMGs] \cite{chen2013prism}, are an extension to MDPs. Rather than having just a series of states a model can move into, it allows the modelling of a turn based style interaction to reflect reflective or competitive interaction. This is beneficial as it allows a more realistic interaction than an MDP; players can be more effectively given aims and act in specific ways to try and reach certain outcomes. 

The difference between an SMG and an MDP is the way  each traversal option in a state has to be associated to a player. Moves can be non-deterministic or probabilistic, as in MDPs, but a transition is ``performed'' by one player. The culmination of these transitions can be used to evaluate a strategy; with the move-set of a player defined, it is possible to determine what actions each player would need to take to reach a specific outcome. The coin example being used so far isn't ideal for displaying this, as there is no competitive aspect to it; however it could still be modelled as an SMG.

It would be possible to have two parties, a ``resetter'' and a ``flipper''. The ``flipper'' has the ability to select he coin to be flipped, and the flip it to get a result. It is then the role of the ``resetter'' to decide as to wether the outcome is final, or the situation is to be reset, causing the flipper to have to start again. To model this as an SMG model, the ``fliper'' would be assigned the transitions from ``pick'' to the possible outcomes of that decision, namely S$_1$ and S$_2$, and also the transitions that ``flip'' between the coin states $S_1$ and $S_2$ and the results states of $S_3$ and $S_4$. The ``resetter'' would be assigned the transitions between the results states and the initial state, $S_0$. This would mean that the picking action is attributed to the ``flipper'' player, as well as the flipping actions. The resetting action is attributed to the ``resetter'' player.  A strategy could then be formed to show how the state of $Heads$ could be reached. That strategy could be represented in a table style form, as shown in table \ref{smgTable}. 

\begin{table}[h!]
\centering
\begin{tabular}{ c || c || c }
  \hline                       
  Party & Action & Outcome \\
  \hline
  flipper & Select coin & coin a  \\
  flipper & Flip coin (a) & Tails \\
  resetter & Reset & -  \\
  flipper & Select coin & coin b  \\
  flipper & Flip coin (a) & Heads \\
  \hline  
\end{tabular}
\caption{A table showing how SMGs link transitions to parties}
\label{smgTable}
\end{table}

Table \ref{smgTable} shows what would happen if the first flipping of a coin yielded $Tails$ instead of heads the first time. The flipper initially non-deterministically selects coin $a$. The flipper then flips the coin, and has a result of $Tails$, with 0.5 being the probability of that result.
The resetter then decides to reset the situation, as the correct result has not come up. 
The flipper then picks again non-deterministically, this time opting for the biased coin $b$. Note the selection of the coin is still a non-deterministic choice, regardless of the previous result. The player may chose the same coin or may choose another for some reason, but it is not a probabilistic outcome. The flipper then flips the coin, yielding the desired $Heads$ result, with a 0.8 probability of this being he result from that coin. 
The resetter then does not need to reset the coin as the desired outcome has been achieved.



\section{Probabilistic Model Checking}


Probabilistic model checking [PMC] \cite{gentle} allows a model the be analysed, giving probabilities of outcomes based on the information provided in the model itself. This method of analysis lends itself well to the verification of real world systems, and has many applications such as the analysis of failure probabilities to the application here, the probabilities of different outcomes in a contract signing protocol. There are many types of models that are covered by probabilistic model checking, and three that are important to this project; Discrete Time Markov Chains, Markov Decision Processes, and Stochastic Game Models. Each of these have been discussed above, and here we will look at how they translate to PRISM models.

 Model checking is advantageous to simply relying on frequent manual simulation, for two main reasons. Firstly, the size and complexity of these systems mean relying on manual testing would both be lengthy and likely erroneous. The second reason manual testing the system is the unpredictability of a system based on non-determinism; there are case where planning every set of possible outcomes and choices would be near impossible, it is far more preferable to have PRISM check all possible states and transition options. \\
 Model checking also allows the modelling of real life issues and can be used to quantify occurrences such as failure to deliver messages or a players dishonest interaction. These types of occurrences are common place in communication across a network, however assessing them with 
 %%%%%%%EXPAND

\subsection{The PRISM Model Checker}

The PRISM model checker, \cite{Pri}, is a tool that allows the modelling and then analysis of systems that can be viewed as random or probabilistic. After the system has been modelled, properties can be checked; properties can be verified, and experiments can be performed to produce quantifiable data, either as numbers or as a graph. 

The models themselves are built up using modules and variables. Variables here behave much the same as in the majority of programming languages, however there is one key difference; as the focus here is the states a system goes through, the variables created can only be of type integer. This allows the number of states to be represented, as each variable has a range of values associated with it in its declaration. Modules represent a distinct part of the system, and contain both variables and commands. The collective states of each variable give the state for the module. Commands are where logic is applied, and take the following form: 

\begin{lstlisting}
    [label] guard -> probability1 : (update1) + ... + probabilityN : (updateN);
\end{lstlisting}

The label is simply the name of the command, and is used for identification and synchronisation purposes. The guard takes the form of conditions that must be met in order for the command to be executable. Where different modules feature commands with the same label, the conditions in all modules with that command label must be met for the commands to run, and the updates will happen together. If the case arises where there is a module with multiple commands with the same label, the conditions will decide which one is executed; if multiple commands feature both the same label and conditions that are met, PRISM will select one option to execute non-deterministically. This allows implementation of triggers across modules; if one module is required to update a variable based on the action in another module, it is possible to use the same name for actions in both modules and have the updates occur simultaneously.\\
The probabilities featured in the updates can either be expressed as a decimal number, or as a equation involving variables in the model. The probabilities must be positive, and cannot sum up to more than one for any single command; in the event of an equation being used for the probabilities, this may require enforcing through the use of conditions in the guard. The updates, denoted by a variable name followed by an prime, change the desired variables to new values; again, these can be expressed as numbers or equations featuring variables. The updates must be contained in a set of brackets.

Declaring variables constant externally to any modules allow user input at run time. As the model is analysed, PRISM will ask users to enter a value for this constant; this allows users to check validity whilst changing certain dependant variables for a specific run.

Logic is applied directly in PRISM; $ \& $ for AND logic, $ \mid $ for OR logic, ! for NOT and = for equals. This logic can be applied in full in the guard, however ampersands are used to change multiple variables per update.


%This allows implementation of triggers across modules; for instance in one of the models featured in this project, when party "O" sends a commitment using command [sendO], the other party "R" features the command [sendO] with the condition "true". This leads to R being able to update a variable every time [sendO] is invoked.

\subsection{Example PRISM Models}

The following models serve to demonstrate to the reader how the current examples of coin flipping can be modelled in the PRISM model checker. They are based on the examples seen in the previous chapter, showcase the coin flipping examples.

\subsubsection{DTMC}

The first such model shows how a DTMC model can be modelled in PRISM. The interaction being modelled is based on the coin example shown in figure \ref{dtmc}. A solution to modelling this in PRISM is shown below.

\begin{verbatim}
dtmc

module coin

  flipped : [0..1]; //1 for flipped, 0 for not
  result : [0..2]; //1 for heads, 2 for tails

  [flip] flipped=0 & result=0 
    -> 0.5 : (result'=1) & (flipped'=1) 
      + 0.5 : (result'=2) & (flipped'=1);
  [reset] result!=0 & flipped=1 -> (result'=0) & (flipped'=0);
	
endmodule
\end{verbatim}

The first line, reading {\tt dtmc}, is what defines this as a DTMC model inside the PRISM model checker. It is important that models are labelled correctly; an MDP model is not executable when marked as a DTMC model. However, in some types of models there is overlap; it is possible to model DTMCs and declare them as MDP models.
As can be seen, the coin itself has been expressed as a module. This demonstrates how real word objects can be abstracted into a PRISM module, not in a dissimilar way to how it can be done in an Object-Oriented style environment. Here, modules still have their own variables to represent different features or states of the module, and a set of executable commands. 


Listed below are the variables used in the DTMC modelling of the interaction shown at Figure \ref{dtmc}.
\begin{description}
\item[flipped] Stores the value that symbolises whether or not the coin has been flipped and would then have a result. 1 is used to represent that the coin has been flipped, a 0 means that it hasn't.
\item[result] The result variable is used to store the current result of the coin flipping. 0 is no result, 1 is a heads result, and 2 shows a tails result.
\end{description}

Below are the commands featured in the model of Figure \ref{dtmc}.

\begin{description}
\item[flip] The action that ``flips'' the coin. Takes a non-flipped coin, and then updates that coin's {\tt flipped} and {\tt result}. The {\tt result} variable then has a 0.5 chance of becoming $Heads$, or 1, and a 0.5 chance of being updated to $Tails$.
\item[reset] Represents what would happen if the coin were to be ``reset'', or just picked up ready to be flipped again. As such, the variable {\tt flipped} is rest back to 0, to show the coin doesn't have a result displaying. As such, the {\tt result} variable is also set to 0, symbolising the coin no longer shows a face result.
\end{description}

Whilst the {\tt flip} action is easy to identify on the diagram at figure \ref{dtmc} as the transitions from the $Flip$ state $S_0$ to the $Heads$ and $Tails$ states, labelled $S_1$ and $S_2$ respectively, the {\tt reset} command isn't labelled. To be clear, {\tt reset} models the transitions from the results states $Heads$ and $Tails$ back to the $Flip$ state, $S_0$. It is also worth noting how when modelling the transactions, it is not necessary to model each one individually; by implementing the probabilistic changes in the update of the {\tt flip} command, both the transitions from the $Flip$ state can be modelled at once. 
%%%%%%%%%%%Expand on correspondence between states S_0 etc.

\subsubsection{MDP}

It is also possible to construct MDP models in PRISM. Whilst, as stated above, it is possible to simply turn the previous DTMC model into an MDP, it is more beneficial to look at an example that shows commands that can be non-deterministic in nature. Therefore, the two coin example featured in figure \ref{mdp} has been modelled here as an MDP.

\begin{verbatim}
mdp

module coin
  coin : [0..2]; //1 for the honest coin, 2 for the rigged coin
  flipped : [0..1]; //1 for flipped, 0 for not
  result : [0..2]; //1 for heads, 2 for tails

  [pick] flipped=0 & coin=0 & result=0 -> (coin'=1);
  [pick] flipped=0 & coin=0 & result=0 -> (coin'=2);
  [flip] flipped=0 & coin=1 & result=0 
    -> 0.5 : (result'=1) & (flipped'=1) + 0.5 : (result'=2) & (flipped'=1);
  [flip] flipped=0 & coin=2 & result=0 
    -> 0.8 : (result'=1) & (flipped'=1) + 0.2 : (result'=2) & (flipped'=1);
  [reset] result!=0 & flipped=1 -> (result'=0) & (flipped'=0) & (coin'=0);
	
endmodule
\end{verbatim}

There is only one additional variable used here that is not present in the MDP model, {\tt coin}. This variable stores which coin that has been picked, 0 being no selection as of yet, 1 is the normal coin, and 2 is the biased coin. There is also a new command, {\tt pick} that represents the transitions from the starting state to the coin states.

Note here how there are two instances of both the {\tt pick} and {\tt flip} command. This is for different reasons. The {\tt pick} commands are selected by the model checker non-deterministically; there is no difference in the logic contained in the command guards, so either can be selected when the guard is true. The only difference is the outcome of that command, to be chosen non-deterministically.\\
The two {\tt flip} commands are featured for a different reason however. Whereas before there where two commands required for the random style selection, there are now two commands based on the input to that command. There is now a difference in the guards; one command is design for use with the normal coin, one for use with the biased coin. As such, the two commands also feature different update values reflecting the two sets of of probabilities.


\subsubsection{Prism for Games}
There is an extension to PRISM which includes support for SMG style models, PRISM for Games {FINDCITE}.
There is one key difference to how SMGs are portrayed in PRISM compared to MDPs. As well as modules, players themselves must be defined, and given a list of actions they are able to execute. This allows the model checker to associate certain transitions with certain parties, allowing strategies to be built. It is not a necessity for the players defined to represent specific modules; actions from different modules can be used. Nameless actions can also be assigned to player, by including the name of the module in the list of actions for that player; this assigns all the nameless actions from that module to be assigned to the player, not all the actions names in that module.

\subsubsection{Example Game Models}

Here, the SMG style properties can be added to the existing code. The changes required are as follows:
\begin{minipage}{\linewidth}
\begin{lstlisting}
smg 

player flipper
  [pick], [flip]
endplayer

player resetter
  [reset]
endplayer
\end{lstlisting}
\end{minipage}
This code would need to be put at the top of the file, {\tt smg} replacing the current {\tt mdp} declaration. The two {\tt player} declarations divide up the available actions into appropriate groups, the groups being discussed earlier during the section on SMGs. The {\tt flipper} takes on the actions  that would ``pick'' and ``flip'' the coin, and the {\tt resetter} would then be the party responsible for the ``reset'' of the coin. It would now be possible to define a property to find a strategy of obtaining a ``Heads'' result; this strategy could be the creation of either party, or potentially both. It would include all actions required by that party required to achieve the outcome required by the property.

PRISM for Games numbers the parties internally; when referring to the above parties, it is both valid to refer to them as {\tt flipper} and {\tt picker}, as well as 1 and 2. This will be shown in an example property later in the chapter.

\subsection{Properties in PRISM}

Properties in PRISM are expressed in PCTL \cite{}. They allow statements and conditions that models may fulfil to be checked against the models themselves. Common properties could include things such as the number of steps execution of a model takes, or the maximum probability an occurrence could arise in a particular model. 
These properties can be either verified once, or if there is input into the model, such as an undefined constant integer, they can be assessed many times over a defined range in the form of an experiment. 

\subsection{Property Specification in PRISM}

Due to the nature of probabilistic model checking, it is necessary for PRISM to be able to accommodate certain types of key operators and notations used in the field. These primarily come into use with the properties being assessed, rather than the model.
These properties are made up of conditions which ideally would be met, as well as different operators that can be used to set what is being assessed about the property. Such operators are:
\begin{itemize}
\item $F$ means that the condition that follows it will be fulfilled at some stage in the future. There is no guarantee of length or when that will be, just the knowledge that a given condition will or wont be fulfilled. In mathematical notation, this is often referred to as $\diamondsuit$.
\item $G$ represents that all future states will fulfil the condition. In mathematical notation, this is often referred to as $\Box$.
\item $FG$ is the combination of $F$ and $G$. The operator checks that there is a future state whereafter all states fulfill the condition.
\item $GF$ is a combination of the $G$ and $F$ operators. It states that for all states, there will always be a future state where the condition holds.
\item $P$=$?$ provides the user with the probability of a certain condition being fulfilled under any sequence of possible moves. This condition can incorporate both the $F$ and $G$ operators, and can be set to a specific value to check that states that meet a certain condition do not arise with an unwanted level of probability.
\item $P{_{max}}$=$?$ provides the user with the maximum probability of a certain condition being fulfilled. This condition can incorporate both the $F$ and $G$ operators. 
\item ${\tt \ll \gg}$ means PRISM will only consider strategies that can be forced by the players identified between the brackets, and this is placed before each condition in the property. This is only available for use with SGM models.
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/FG.png}
\caption{Different F and G things}
\label{FG}
\end{figure}

Figure \ref{FG} illustrates how the $F, G, FG$ and $GF$ operators work with respect to goal states and state progression. The first line shows how $F$ means a goal is eventually satisfied in a futur state, whereas $G$ is satisfied at every state for the entire duration. THe line that is labelled $FG$ shows that the $G$ condition will be fulfilled, for all subsequent states, at some future state, $F$. The line labelled $GF$ demonstrates how in every state it is true that the goal will be satisfied in a future state; it also shows how this is still the sace even after the goal state has been reached.

\subsubsection{Example Properties}
It is possible to construct properties that allow certain verification against the models described to represent the coin flipping examples shown previously. The first, looks at the maximum probability of ever achieving a heads result.\\

\centerline{\tt Pmax=? [F (result=1)]}

In this example, {\tt Pmax} is used as the maximum probability is a feature of interest; the inclusion of the {\tt ?} means that a numerical result will be returned giving the maximum probability. The use of {\tt F} means that the condition can be met in any possible future state, with the condition here being {\tt result=1}. As previously, the variable {\tt result} is equal to 1 to represent a ``heads'' result.\\

\centerline{\tt [G (result>0|flipped=0)]}

The above property allows verification that either the coin hasn't been flipped or there is a result, helping to ensure that the logic holds in every possible state.The {\tt G} symbolises the fact that the condition must hold for every possible state in the execution of the model. The first part of the condition, {\tt result>0} holds true when there is a result, and the coin is representing a ``tails'' or ``heads'' result. If this is not the case, then the coin should not be flipped, being represented here as {\tt flipped=0}.\\

\centerline{\tt <<1>> Pmax =? [F (result=2)]}

This property can only be checked against the model once it has been expanded to an SMG. It looks for the maximum probability that at some future state, the result will be a ``tails'' result. The use of {\tt <<1>>} expands on this; PRISM will only look at states that player 1, also know as the {\tt flipper}, can use a strategy to achieve.\\
Player 1 represents the selection of the {\tt flipper} as it is the first player defined in the SMG model; it would have been just as valid to use {\tt <<flipper>>} in the property.



%\subsubsection{Games Properties}
%The properties in PRISM for Games work in an identical way to the properties used for the other types of models; however it is now possible to create a strategy to achieve a goal laid out in a property. It also possible to force the model checker to act in such a way that only certain parties participate in the creation of such a strategy; this type of behaviour is particularly beneficial if one wants to determine how a particular party can force a particular outcome. Game properties feature an expression that other PRISM models do not; the ${\tt \ll \gg}$ operator. This is expressed before each condition, however each property can feature more than one condition. An identifier for one or more players is entered between these brackets, and then only strategies these parties can employ to fulfil the condition are considered.
% To continue with the coin example as shown previously, the following property finds the maximum probability of achieving a ``Heads'' result.

%\centerline{$\ll1\gg$ Pmax=? [F result=1]}

%Running this in PRISM, forces PRISM to consider the move set of the {\tt flipper}, and defines a strategy that they can employ to satisfy the condition.



\chapter{The Protocol}
The basis for this project is the contract signing protocol detailed by Aizatulin, Schnoor and Wilke in \cite{ASW09}. The protocol takes a ``gradual commitment'' approach, and the steps of the protocol are laid out below. There are two parties here; party $O$, the originator, and party $R$, the responder. Both parties have a contract the other party wishes to have. The originator is the party which initiates the protocol, by sending the first commitment. The responder is the party that the originator wishes to make an exchange with. The protocol sees the parties exchanging commitments until a certain number has been received by each party; at this stage, they will have achieved their desired contracts. The protocol also features a Trusted Third Party, the TTP, which acts as an impartial judge in cases.


\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/CSPinteraction.png}
\caption{The basic interaction in the CSP protocol}
\label{csp}
\end{figure}

This is referred to in the paper as the Gradual Commitment Protocol [GCP]; parties send commitments to each other in turn. These commitments eventually become valid contracts; the party is considered to have the contract when they have received all commitments, totalling $N+1$. The commitments take the form \\

\centerline{CMT${_{X}^{i}}$=$[text, O, R, T, i]_X $ .}

Here, $text$ is the contract, the document both parties are attempting to sign. $O$ and $R$ represent and identify the parties participating in the protocol, the originator and responder, and $T$ represents and identifies the Trusted Third Party. The character $i$ represents the number of commitments thus far, and ideally is therefore indicative of the number of exchanged that have taken place at that point. The symbols $[...]_X$ represent a signed message, $_X$ being the signature of party $X \left ( \in \left \{ O,R \right \} \right )$;
%The number of commitments for each party is $n+1$, this being the number of commitments that are needed to make the entirety of the contract. This leads to one of the key principles of the protocol, and that is that this protocol gives the low balance that it does. The unbalance of any reachable state is not greater than 1/n, in other words 1/n is the highest probability that one party cannot achieve its goal while the other can. It is assumed that the number of commitments per contract is then high, as this would cause the probability to tend towards zero as the number of n rises. This is possible by the inclusion of the TTP the protocol uses.

The TTP described in the paper, \cite{ASW09}, is described as a non-optimistic protocol. Parties can contact the TTP whenever they want to try and achieve the whole contract at that stage. To do this, commitments are used by the parties to create resolve requests. One commitment featured in the resolve request is the most recent commitment received by that party, so for instance party $R$ can form a resolve request, $RR{_{R}^{i}}$ using the most recently received commitment $CMT{_{O}^i}$ provided $i \in \{1,...,N+1\}$. The other commitment featured in a resolution request is the commitment most recently sent by the requesting party, so for party $R$, $RR{_{R}^{i}}$ would also feature the most recently sent commitment $CMT{_{R}^i}$. Resolve requests are also signed by the transmitting party, as with commitments. The exact format of these resolve requests as follows:\\

\centerline{RR${_{O}^{i}}$=$[$CMT${_{O}^{i+1}}$, CMT${_{R}^{i}}]_O$ \hspace{30mm}  RR${_{R}^{i}}$=$[$CMT${_{O}^{i}}$, CMT${_{R}^{i}}]_R$}

Note how the resolve request for party $O$ has an upper value of $i+1$ rather than $i$; this is to help improve balance between the two parties, as the originator has a disadvantage by having to trust the other party. This is the originator has to send the first commitment each round, and each time has to trust the responder to reply with a commitment. This will be expanded upon later, showing more features of the protocol that have been implemented to help mitigate this difference of balance.

There is also one other type of resolve request that can be made. It is possible party $O$ to make a resolve request without having a commitment from party $R$; this is necessary in such a case as party $R$ has refused to send a response to the first commitment. This resolve request is referred to as the ``zero request'', and has a format as follows:\\

\centerline{RR${_{O}^{0}}$=$[$CMT${_{O}^{0}}$, {\tt abort}$]_O$}

Here, {\tt abort} is used as opposed to commitment; {\tt abort} is a fixed token used only for this purpose. According to the rules of the TTP, shown below, it wouldn't be possible to obtain the contract if the zero resolve request alone was sent to the TTP. However the benefit of it arises should party $R$ contact the TTP as soon as possible and obtain the contract; the rules of the TTP, detailed below, would mean that the zero request would be met with the same result as that of the resolve request sent by party $R$.

\section{TTP Rules}
These are the rules the TTP follows if a party contacts it with a request for their desired contract. It can be found in \cite{ASW09} in its original form; here it has been changed to be more readable, as opposed to the more complex mathematical style formulas used in the original paper. The $i$ used is obtained through the resolve request $RR{_{X}^{i}}$; it is equivalent to the $i$ value contained in the received commitment embedded in the resolve request.


\begin{enumerate}
\item If this is the first request, resolve it with probability of $i/N$, and reject with probability $(N-i)/N$
\item Else if this party has made a request before, ignore this request
\item Else if the other party has already made a request, then:
\subitem-- If the other party's request was resolved, the request is resolved
\subitem-- Else if the other party was rejected and the other resolve request, $RR{_{\bar{X}}^{j}}$, has $j$<$i$, resolve with a probability $i/N$ and reject with a probability $(N-i)/N$
\subitem-- Else if the other party's request was rejected and the other resolve request, $RR{_{R}^{j}}$, has $j$>=$i$, reject this request
\end{enumerate}

%The reason that these rules allow a maximum "unbalance" of 1/n is this; there is always an element of risk on the originators part. Whoever sends a commitment first is always going to achieve their contract last, and therefore incurs the risk that once they've sent their final commitment, the other party now with their contract, does not send the final commitment to the originator. With the introduction of the TTP, the originator could then contact the TTP, who would use rule 1 in this instance. If this is the last bit, then the second part of that rule would mean the chances of the originator not achieving the contract would be 1/n.
\subsection{First Rule}
The first rule is designed to give players an increasing probability that they will get the contract the further they are into the protocol. Importantly, there is a probability of success of 1 when party $O$ contacts with the penultimate commitment; this is vital to ensure the property can hold. If this was not the case, a corrupt party $R$ could transmit commitments until the last one, and with it's contract achieved, leave. Due to the originator having to send the first commitment, it relies on honesty from the responder in the final commitment; there is no benefit to the responder to send that final commitment, as it has achieved its goal. Therefore, a way is needed to guarantee that the originator can achieve the contract in this extreme case, and that is the probabilities expressed in rule 1 of the TTP.

\subsection{Second Rule}
The second rule means that parties cannot keep sending requests to the TTP. If this wasn't enforced, there is the risk a party may keep contacting the TTP  to increase their chances of gaining their contract, or even to just slow the TTP down in some way, giving a potential advantage to them over the other party.

\subsection{Third Rule}
The third rule is concerned with parties sending resolve requests the TTP when the other party has already done so. The first clause means that if one party has been successful with their resolve request, so will the second party. This is important as it keeps the protocol fair; the protocol does not want to be in a position where one party can be successful when the other one cannot. The second and third clauses however are slightly more complex, and deal with how the request should be handled if the initial resolve request, sent by the other party, failed. The second clause deals with the situation where one party has sent a resolve request to the TTP, but the gradual commitments have continued to be sent; in such a case, the new resolve request is treated as though it is the first request to arrive, with the same probabilities of success and failure as it would have been if this was the first request and the first rule was being applied.
If the current resolve request doesn't have a higher number of received commitments than the number contained in the previous request, that can mean one of two things; either the other party has just contacted the TTP and been unsuccessful, or there has been dishonesty in at least one of the commitments. In the case of the former, it would be unfair to award the party the contract as the other party has been rejected and has no option as interactions have ceased, due to the number of commitments not being higher. In the case of the latter, and parties are obviously behaving outwith the rules of the TTP, the safest option is to deny the contract to both parties.

\section{The Unbalance Property}


There is one key property featured in the paper; the protocol promises that the probability of unbalance occurring will never reach higher than $1+1/N$.
Balance was defined by Chadha et al. \cite{chadha2001inductive}, for an honest party $A$ and a dishonest party $B$. Balance comes when during an instantiation of a protocol, it is not possible to reach a state where the dishonest party has both a strategy to obtain the contract from the honest party $A$, and also a strategy to ensure the honest party $A$ can never obtain the contract, no matter how the TTP, honest party and the communication channels behave. In the paper,  this has been expressed as follows:\\

\centerline{$ G{_{Pr}},q_{Pr}^{0}\models  \ll A, T, B, X, S \gg ^{>0} \diamondsuit (\ll A, S, B \gg^{\ge Pa} \diamondsuit \varphi{_{abr}}  \wedge \ll A, S, B \gg^{\ge Pr} \diamondsuit \varphi{_{res}}) $}

Due to the complexity of the above property, it has been translated to a more human readable set of conditions:
$\ll participants \gg ^{>0} \diamondsuit (H_{denied}  \wedge C_{successful})$.


\subsection{Breakdown of Property}
Here, $participants$ refers to all the elements present in the protocol; the Trusted Third Party, the honest party, the corrupt party, the buffer, and the strategy. The strategy is the steps taken by the corrupt party to ensure it's goals are achieved. The buffer is the channel the participants use to send messages to each other, both commitments and requests to the Trusted Third Party. Together, these elements have the probability greater than zero that at some stage during the protocol, the two conditions are simultaneously fulfilled.\\
The section of the property $H_{denied}$ refers to the probability that at a certain point in the interaction, the corrupt party has a strategy that will stop the honest party from gaining the contract, either by receiving commitments or contacting the Trusted Third Party. In the paper, this is denoted as  $\ll A, S, B \gg^{\ge Pa} \diamondsuit \varphi{_{abr}}$, the former half showing the corrupt party, strategy and buffer are all participants. \\
The section of the property $C_{successful}$ is the probability that a condition is fulfilled. This condition is that at a certain point in the interaction between the parties, the corrupt party can utilise a strategy to obtain the contract. Again, this can be either by receiving the necessary commitments from the adversary, or by contacting the TTP. In the paper, this is described as $\ll A, S, B \gg^{\ge Pr} \diamondsuit \varphi{_{res}}$. \\
It is not important which party assume which role; the property is described in the paper in such a way as one party assumes the role as corrupt and uses strategies, and the other party is honest. There are no restrictions on this.
\subsection{Additional Requirements}
As in the definition provided by \cite{chadha2001inductive}, here there are also certain additional conditions that must be met for the protocol to hold. The first is that every bit that is sent must eventually arrive. The property is no more explicit than this, and no promise is made as to the speed or efficiency of the commitment's delivery; the property simply states every commitment sent arrives in full, eventually.\\
The second is that at no stage of the protocol do the honest party or the Trusted Third Party become corrupt; these parties must only act in an honest manner for the duration of the interaction.


%The property (INSERT) in full is more complex than the promises of 1/N made at the start of the paper. It is revealed that the property itself has a maximum probability of unfairness of 1+1/N, when considering the steps parties can take to achieve their goals. Much of the property is not needed to be modelled in the property being used in PRISM due to the model being used.
%The first part of the property, $\langle \langle A, T, B, X, S \rangle \rangle ^>0$, describes the participants involved in the property. Here, a is used to represent the player who is aiming to gain the contract and block the other party from gaining theirs, ie. the corrupt party. T here is the Trusted Third Party, which is designed both as a module and a player within the model. B, which is used to represent the interaction of the buffer, isn't required to be modelled as the model has been designed assuming that sent commitments reach their intended recipient in a timely manner. It is worth noting however that if and when required, this action can be simulated with the using the ignore command; it is equivalent to the behaviour of one party deciding the other has timed out. X is the set of the parties, \{ O, R \} . It is used to denote the honest party. S is there for some reason.
%This section of the property then does not required to be modelled in the property; all the participants are either represented within the PRISM model, or the model has been designed in such a way as the role of that participant is already accounted for.\\

%The two following sections are of importance to the property however. $\ll A, S, B \gg^{\ge Pa} \diamondsuit \varphi{_{abr}}$ and $\ll A, S, B \gg^{\ge Pr} \diamondsuit \varphi{_{res}}$ describe the attitude to unfairness the property takes. Note both feature A, S and B, as these are the three parties vital to these sub-properties.
%
%$\ll A, S, B \gg^{\ge Pa} \diamondsuit \varphi{_{abr}}$ is the sub-property that at some stage, involving the three parties, it is impossible for the honest behaving adversary, X, to obtain the contract. In the paper, the translation of abr is described as $abr = \Box (\varphi nc \wedge \diamondsuit\varphi dl \wedge \neg\varphi Xc)$, and it is from here we derive the above explanation. As stated prior, the $\Box$ denotes that there will be a state where this will become true for all following states. $\varphi nc$ denotes the property that neither X nor T will become corrupted, that is to say at no point in the protocol do the adversary or the Trusted Third Party behave in a way that is seen as dishonest, or by operating outside the rules stated in the protocol, such as X refusing to send a bit to A, or the TTP not following the behaviours laid out in the protocol. 
%$\diamondsuit \varphi dl$ denotes that at some eventual state, every message sent into the buffer is delivered. As explained above, this is already ensured by the designing of the model; all messages sent arrive directly, there is no scope for messages sent to not arrive, as this would go against this key property of the protocol.
%The final section of this sub-property, $\neg\varphi Xc$, states that the adversary party, X, is not able to achieve the contract, despite playing fairly as noted above. In PRISM, this property can be mapped as $!(recdBitsX=N+! \mid resultX=1),$ as it is equivalent to say that its not the case that the contract was ever sent to X or that X was successful at having the contract resolved by the TTP.\\

%$\ll A, S, B \gg^{\ge Pr} \diamondsuit \varphi res $ states that there will be state where the dishonest party , A, has the contract. This explanation is obtained through the papers description of $\varphi res$, $\varphi _{res} = \varphi{_{nc}} \wedge \varphi{_{dl}} \wedge \varphi{_{A{_c}}}$. AS before, $\varphi{_{nc}}$ and $\varphi{_{dl}}$ mean that the adversary and Trusted Third Party do not get corrupted and participate honestly, and all bits sent to the buffer are delivered to their intended participant.
%The difference with this property is the last section, $\varphi{_{A{_c}}}$. This is the condition that the dishonest party, A, will achieve their desired contract. In PRISM, this can be mapped as $(recdBitsA=N+! \mid resultA=1)$, with a being either O or R, depending on who is performing the role of the dishonest party.

\section{Corrupt}

The requirement for a party to be determined as being corrupt or not is fundamental to the protocol; it's a key definition that is used to explain this protocols beneficial unbalance property. What the paper is lacking in however is a description of what it is to be corrupt. It is important that the modelling of a corrupt party reflects as many possible actions as a corrupt party could take in a real life situation. Therefore, a corrupt party has been assumed to be capable of any action at any point during it's turn. It is capable of sending commitments regardless of what has been received from the other party, can refuse to send a commitment at all during it's turn, and can contact the TTP during any stage of the protocol where it is able to select an action. This means that it can send multiple commitments in a round, behaviour which any honest party would treat as suspicious.

\section{Honest}

Honesty is also a key concept that requires definition due to the description of the unbalance property. Again, the paper lacks a definition of what an honest party is capable of whilst still being considered ``honest.'' Here, it has been assumed that an honest party has a more restricted level of interaction than that of a corrupt party. An honest party will only send a commitment if and only if the other party has sent commitments appropriately; that is, an honest party will only refuse to send commitments if it has reason to be suspicious of the other party. Suspicious activity here has been treated as failing to send a commitment. It is also assumed that an honest party can also contact the TTP at any stage, however if it does so it will not be able to send a commitment that round; the honest party must chose between sending a commitment or contacting the TTP, therefore not being able to hide its attempt at sending a resolve request.

\section{Fairness}

Any protocol that deals with multiple parties should be fair. Fair here is used to describe a protocol that does not give an advantage to one party at the end of the interaction. Either both parties are successful or neither is; similar to a NOT XOR logic gate. The table at \ref{fair} below shows the possible outcomes of the protocol in terms of which parties receive the contract, and each will be labelled to indicate whether this is a fair or unfair outcome, provided both parties act honestly. It is not seen as unfair for a corrupt party to be unable to achieve the contract at any stage; parties that do not obey the rules of the TTP should not receive the same degree of support as those that do follow the rules of the protocol.

\begin{table}[h!]
\centering
\begin{tabular}{c|c || c}
 Originator Result & Responder Result & Fair?  \\
 \hline
 Successful & Successful & Yes \\
  Successful & Unsuccessful & No \\
    Unsuccessful & Successful & No \\
      Unsuccessful & Unsuccessful & Yes
 
\end{tabular}
\caption{A table showing which outcomes of the protocol are considered fair with honest interaction}
\label{fair}
\end{table}

\section{Related Works}

As part of the background research into this project, it was deemed beneficial to examine other protocols that both fulfilled the "contract signing" criteria, and also introduced in further detail concepts such as optimism, non-optimism and non-repudiation within these protocols.

Rabin's protocol \cite{rabin1983transaction}, is a non-optimistic CSP. This means it involves interaction with the TTP every instance of the protocol, regardless of the behaviour of the parties involved. Every day, the third party broadcasts an integer between 1 and a pre-defined N. Prior to the exchanging of information between the parties, the parties send messages to each other of the following form:
\begin{lstlisting}
    I am committed to C, if integer i is chosen on date D.
\end{lstlisting}
A send this to B, who then replies with the same message. Party A would the retransmit with the "i" updated to "i+1". The idea here is that provided B responds when they are contacted by A each time, when the integer between 1 and N is transmitted daily by the third party, if that integer fulfils one parties promise, it will also fulfil a promise made by the other party. There is a risk however that transmission is not always guaranteed by both parties; consider the situation where A sends a commitment immediately prior to the transmission. Consider here what would happen should the transmitted integer match the one proposed by A; B would be under no obligation to send their contract, unlike party A. This leads to the probability of only one party being committed in the termination state is $1/N$.

The BGMR protocol, \cite{ben1990fair}, is similar to Rabin's in that it has the same goal - to allow  two parties to exchange commitments to a pre-defined contract. There is however a greater focus on the concepts of privilege and fairness. The protocol is such that it can never be the case that only one party can achieve the contract. The behaviour of the protocol is very much similar to that of Rabin's, exact that instead of transmitting a target integer, the two parties send ever increasing probabilities the protocol will resolve before a deadline. Ideally, the parties reach the probability of one; however, if there is an issue with receiving an expecting commitment, the differences to Rabin's begin. If a party contacts the third party, referred to as a judge, the judge takes not of the latest probability that the contract will be fulfilled. Then, after the deadline passes, the judge resolves the contracts for both parties with the probability stipulated in the the transmission to the judge. BGMR assumes that the transmissions between parties have  digital signatures that cannot be forged, meaning the judge does not need to be concerned with fraudulent requests.

Asoken et al. \cite{asokan1998optimistic} defined the concept of timeliness as ``one player cannot force the other to wait for any length of time - a fair and timely termination can be forced by contacting the third party.'' As such, Norman and Shmatikov \cite{norman2006analysis} introduce an extension to BGMR, referred to as Timely BGMR, or TBGMR. The difference between BGMR and TBGMR is that when the third party is contacted in TBGMR, the TTP makes its decision immediately. Then, once the verdict has been announced and reaches an honest participant, the honest participant ceases communication.

All three protocols are analysed by Gethin and Shmatikov in \cite{norman2006analysis}, using the PRISM model checker, \cite{Pri}. TBGMR is shown to have a weakness; there is an attack strategy for a corrupt party that can cause unbalance with a high probability. There was also found a quantification for the trade-off between the probability of the attacker winning and the requirement to delay messages from the TTP to the honest party.




\chapter{DTMCs and the first Model}
\section{Rationale}
 The first iteration of the model was built to accommodate the functionality expressed in \ref{csp}, the most simple interaction a CSP can fulfil. DTMC models are ideal for this type of interaction, as there is only one action that can be taken at any one point; there is a predictable style of interaction. Here, probabilities of moves are not required, which simplifies the model further. Turns are featured, to ensure a the players send commitments alternately. Below is the model built in PRISM for the first iteration, in full.\\

\begin{center}
\verbatiminput{dtmc.pm}
\end{center}

The naming conventions used in the model is slightly different to the one featured in the paper. This was primarily due to the length of the terms used in the paper, as well as other protocols of a similar nature using different key words. As such, included here is a list of the variables and commands featured in the model and and explanations to the purpose each is used for. $X$ ranges over party $O$ and party $R$, $X \in \left ( \in \left \{ O,R \right \} \right )$

\subsubsection{Variables}
\begin{description}
\item[sentBitsX] Represents the number of commitments that particular party has sent. With honestly playing parties, can be used to determine how many ``rounds'' have been completed.
\item[recdBitsX] Represents the number of commitments a particular party has received during the protocol. Once a party has received $N+1$ of these, they are considered to have achieved the contract. These should at any stage be the same as the opponents {\tt sentBitsX} value.
\item[turnX] Used to represent whose turn it is. Has three possible values; 0 symbolises that it isn't that parties turn. 1 is used to signal that it is that parties turn. 2 is used to represent that the party has finished.
\item[N] Used by the model to store globally the predefined value of N. Accessed by all, changed by none.
\end{description}
\subsubsection{Commands}
\begin{description}
\item[begin] This is the first command to execute, determined by being the only command to be executable when both parties turn is set to 0. This sets the Originator's {\tt turnO} variable to 1 and the Responder's {\tt turnR} to 0, causing the Originator to go first. 
\item[sendX] This command makes all the necessary changes to both modules to resemble sending a bit. Featured in both modules for each party, one command increases the senders {\tt sendBitsX} variable and sets that senders turn 0. The other command increments the recipients {\tt recdBitsX} variable and sets that party's turn variable to 1.
\end{description}

Note here the corresponding commands in each module, noted by the same label. For these to be executable, the guards in both need to be satisfied. The reason for having these multiple commands is so that when say party $R$ sends a commitment, by updating its {\tt sentBitsR} varibale, party $O$ can receive the commitment and update its {\tt recdBitsR} variable and set its turn variable to 1; as stated previously, a command in one module cannot update values in another.

The model expresses the ideal protocol when both parties act honestly without contacting the TTP, using the definition of honesty found as described in the previous chapter. That is to say, both parties honour the exchange and send each other commitments until the entire contract has been received by both parties. 


\section{Analysis}

Analysis of the DTMC was concerned with ensuring that the model behaved in the predicted manner. A list of properties where created in PRISM to ensure that all possible outcomes of honest interaction where as they should be. This excludes interaction with the TTP; this model was designed purely to model achievement of the protocol by the use of the Gradual Commitment Protocol. The first of these such properties is as follows:

\begin{lstlisting}
            P=? [((recdBitsR=N+1)&(recdBitsO=N+1))]
\end{lstlisting}

This property finds the probability of both parties gaining the contract. Recieving the contract is denoted as {\tt recdBitsX} being equal to $N+1$, as per the protocol describes. The result of this was 1 as expected; this is because the parties send gradual commitments until both have achieved the protocol. This key as it meant that the most basic function of the protocol had been implemented; two parties could make gradual commitments until they were both satisfied by gaining the complete contract.

The model was also checked for the case where neither party was able to achieve the contract; this was modelled by the property:

\begin{lstlisting}
                Pmax=? [ G !((recdBitsR=N+1) | (recdBitsO=N+1)) ]
\end{lstlisting}

The justification for checking this property is less trivial; although a protocol where this can happen is still to be considered fair, this should not happen here. It was vital to ensure that should the two parties act in honesty for the duration of the protocol, then they will still be successful. This highlights the difference between a fair protocol and a balanced protocol. The maximum probability was indeed 0 as intended.

The final stage to ensuring that the model wasn't unfair was to ensure that it cannot be the case that only one party is successful. Here, that was assessed by a two properties as expressed below. 

\begin{lstlisting}
     P=? [ G ((recdBitsR=N+1)&!(recdBitsO=N+1) ]     P=? [ G (recdBitsO=N+1)&!(recdBitsR=N+1))]
\end{lstlisting}

This gave a maximum probability of 0, meaning that neither of these situations can arise, which was expected. This means that neother party has an advantage here in achieving their goal and denying their opponent.


It is also important here that the unbalance property is met, with there being no states where the probability of unbalance is no higher than the promised thresh hold of $(1+1/N)$. Despite the fact both of these parties are honest, and there is no corrupt party present, there is no reason a party deemed to be corrupt in the model cannot act as an honest party, so the property should still be checked. The unbalance property was modelled here as shown below. As discussed previously, the unbalance property is the sum of two probabilities; the probability of there being a strategy that gains one possibly corrupt party the contract, and the probability of there being another strategy that ensures the honest adversary is never successful in gaining the contract. 

\begin{lstlisting}
(P=? [ F (recdBitsR=N+1)]) + (P=? [ G !(recdBitsO=N+1)])
\end{lstlisting}

The probability of unbalance was shown to be zero; this is expected, as due to the inherent honest nature of the parties in this version of the model, it shouldn't be possible for one party to cheat the other out of getting the contract. The lack of a TTP shouldn't impact the results, as the states reachable here can be treated as a subset of the states possible in a fuller model; there's no requirement a party has to contact the TTP, therefore the states achieved here are fully possible in a full model.


Due to the size and limited nature of the model, it is possible to show a complete run of the protocol via manual simulation in PRISM. Whilst the model has been shown to possess the required and expected properties, it is beneficial to the reader to see how PRISM treats execution of the models in terms of executions of actions and the updating of values. Therefore, an example manual simulation has been featured below.

\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/dtmcResults.png}
\caption{The results of manual simulation of the DMTC in the PRSIM engine}
\label{dtmcEx}
\end{figure}

As shown in figure \ref{dtmcEx}, the behaviour of the model is as predicted. Commitments, referred to in the model as $Bits$, are sent back and fourth each round until completion. Upon receiving it's final, $N+1$th commitment, party $O$ goes into a loop with it's $turn$ variable being set to 2; this is to represent the end of the protocol. 
At no stage during the interaction is there a choice; the model limits actions in such a way as at any time, there is only one possible action. This is enforced here by the specific logic used in the guards in the model.

\subsection{Limitations of the DTMC}

As mentioned previously, the model does not allow for the full range of interaction possible in a protocol such as this. Having the model be a DTMC means that there cannot be multiple actions possible at a given point, without providing probabilities of what may or may not happen. This is unsuitable as interaction of party cannot be thought of in terms of probability of actions; the parties make choices that are non-deterministic, such as the choice of a corrupt party to either send a commitment or not send a commitment. These are real world choices meaning there isn't information that can be used to guess what is going to happen. 

Despite being limited in terms of how much of the protocol can be modelled, the model is in itself a success. It is an important step to modelling the complete model, and successfully represents the Gradual Commitment Property. The construction of the model also served to help familiarity with the PRISM model checker increase.

\chapter{MDPs and the Second Model}

\section{Rationale}
The introduction of non-determinism via an MDP style model is vital; the protocol describes parties as being able to make a choice, be it choosing to send a bit, ignoring a party or contacting the TTP. Therefore it is necessary to take the DTMC model and convert it to an MDP model. 


\section{Model Changes in PRISM}

MDPs are required to implement a model that allows each party multiple choices per turn; choices such as not sending a commitment or contacting the TTP. The second version of the model takes advantage of this, allowing different commands to be executed in each module, representing different actions a party could take in a CSP. These choices, in this version of the model, are made non-deterministically; the different commands have guards such that multiple commands are executable each turn. It is important to note that in this version of the model, the parties can choose one action per turn; they may send a commitment, not send a commitment, or contact the TTP to try and achieve the contract.

\subsection{Introduction of Interaction}

To accommodate the expanded actions possible in an MDP model, it is necessary to add more commands to each of the modules to achieve a model that more closely represents the protocol. The additions to each model are similar, and the additions made to party $O$ are shown below. Note how the guards in the {\tt reqO} and {\tt ignoreO} commands have conditions where they can both be fulfilled, as can {\tt sendO}. This is what gives the model it's non-deterministic property and allows the MDP to take place.
\begin{lstlisting}
  contactO : [0..1]; //1 represents contacted TTP, 0 represents no contact
  resultO : [0..2]; //1 represents resolved contract by TTP, 2 represents rejection
  //0 represents no result has been achieved through resolve requests
	
  //can contact TTP provided it hasn't done so
  [reqO] turnO=1 & !(contactO=1) & recdBitsO<=N & recdBitsO>=0 -> (contactO'=1);
  [replyO] sendO=1 ->(resultO'=responseO) & (turnO'=0);
  [replyR] turnO=0 -> (turnO'=1);
  [ignoreO] turnO=1 & !(contactO=1 & resultO=0) -> (turnO'=0);
  [ignoreR] turnO=0 -> (turnO'=1);
\end{lstlisting}

The action $reqO$ represents the party making a resolution request and contacting the TTP. Here, the number of received commitments has to be greater than or equal to zero; in the party $R$ equivalent, this number is set to 1. This is due to the different ways the two parties can make resolve requests; as party $O$ has the capability of forming the zero request, it requires no received commitments to form a valid resolve request. Party $R$ still requires at least one received commitment to form a valid resolve request. The reason for this is the Originator has the capability to create a zero commitment resolution request, unlike the responder. With the exception of this change, the Responder version of these additions are identical. After the TTP has been contacted, the action $replyO$ will be executed, updating the variable $resultO$, which is used to store the results of a resolution request. The command $ignoreR$ is used to end a party's turn without requiring it to send a commitment.

The commands $replyR$ and $ignoreR$ are used solely to update the turn variable when the other party has taken their turn. This is required as it is not possible for a module to update a variable stored within another module. It is however possible for one module to use the values stored in a variable in another module for logical purposes.

There is added logic to the [reqX] command not present in the description of the protocol. As the TTP is designed to ignore requests from parties who have already contacted it, a problem presented itself in the from of mapping out this behaviour. It was decided that as there is no difference in terms of states between a party being ignored by the TTP and that party not contacting the TTP; the outcome is identical. This stops either party spamming infinite caused by repeatedly contacting the TTP, without receiving a response. It was also decided that in practical terms, any party participating in the protocol would be familiar in the rules of the protocol, and therefore would be unlikely to make a second request regardless.\\


\subsection{Implementation of the TTP}

The TTP also now requires modelling in a PRISM model. The implementation of this, below, is almost a direct translation of the rules stated earlier in the paper, and found in CITEHERE. The only slight addition is the inclusion of a reply command; this is purely for reasons of simplicity. Whilst it is possible to implement an action that modelled the contacting of the TTP in a single move, the solution would be complicated and a likely source of error. Therefore, a reply command has been added, and whilst this requires two moves in the PRISM simulator, the outcome matches what is required here. Having this broken into two stages also helps enforce the impression the TTP is a complete separate party all on its own; in a practical application, there will be concerns of data transport, and having the reply as a separate action helps better emulate this interaction.
\begin{minipage}{\linewidth}
\begin{lstlisting}
module tTP
  responseO : [0..2]; //1 for resolved, 2 for rejected
  iO : [0..N+1]; //stores number of commitments for party's first contact
  sendO : [0..1]; //trigger for sending back result

        
  //1) if no one has contacted, follow logic for rule 1
  [reqO] (sendO=0 & sendR=0) & responseO=0 & responseR=0 & recdBitsO<=N 
    -> recdBitsO/N : (responseO'=1) & (iO'=recdBitsO) & (sendO'=1)  
      + (N-recdBitsO)/N : (responseO'=2) &ryrtyrtyr (iO'=recdBitsO) & (sendO'=1) ;

  //2) if the party has contacted previously, ignore following rule 2
  [reqO] (sendO=0 & sendR=0) & responseO>0 -> true ;
    
  //3a) if other party contaced and was resolved, resolve request as rule 3a
  [reqO] (sendO=0 & sendR=0) & responseO=0 & responseR=1 
     -> (responseO'=1) & (sendO'=1) ;

  //3b) if other party contacted and was rejected and other party had fewer commitment
  [reqO] (sendO=0 & sendR=0) & responseO=0 & responseR=2 & iR<recdBitsO & recdBitsO<=N 
    -> recdBitsO/N : (responseO'=1) & (sendO'=1) 
      + (N-recdBitsO)/N : (responseO'=2) & (sendO'=1) ;

  //3c) if other party contacted, was rejected and had more commitments, reject
  [reqO] (sendO=0 & sendR=0) & responseO=0 & responseR=2 & iR>=recdBitsO 
    -> (responseO'=2) & (sendO'=1) ;

  //used to send the result after the descision has been made
  [replyO] sendO=1 -> (sendO'=0) ;

endmodule

\end{lstlisting}
\end{minipage}

As stated, the actions in the code above correspond to the rules obeyed by the TTP as described in the paper. Taking the request command for rule number 3a, this can be shown.

\begin{verbatim}
  [reqO] (sendO=0 & sendR=0) & responseO=0 & responseR=1 
    -> (responseO'=1) & (sendO'=1) ;
\end{verbatim}
The label $[reqO]$ forces PRISM to consider this particular command whenever $[reqO]$ is invoked by any module, in this case being the party O. The guard here fulfils the logic required as follows:
\begin{itemize}
\item (sendO=0 \& sendR=0) ensures that the TTP is not currently processing a request from either party. Were this to be the case, one of thee variables would have been set ot 1, to indicate the reuqest being made from that party.
\item responseO=0 provides a guarantee that this party, O, has not contacted the TTP before. If this were not the case, an instance of [reqO] corresponding to the third set of TTP rules should be invoked.
\item responseR=1 means that the adversary, party R, has contacted the TTP prior and has also been successful. Again, where this condition not to be met, this particular command would not be considered possible to run.
\end{itemize}
There is only one update to be considered here, which means that it will occur with a probability of 1. The variable $responseO$ being updated to 1 symbolises that the party O has been successful in gaining the contract via contacting the TTP. The variable $sendO$ being updated to one allows the logic to be fulfilled for the reply command, which will in effect send the result to the party. 


 Note that again, it is only the additions made in the interest of the Originator that have been included here; this is purely for spacial reasons. There is a near equivalent for the Responder party, with one key difference; the command [reqR], designed to mirror the TTP rule 3b, has the guard:
\begin{lstlisting}
(sendO=0 & sendR=0) & responseR=0 & responseO=2 & iO+1<recdBitsR & recdBitsR<=N
\end{lstlisting}
 As the Originator sends first, that party will have one more sent commitments than received commitments after every honest turn. 
 Therefore, unlike with the responder, there is a different value associated with the two commitments in the resolve requests sent by party $O$, the sent commitments having one count higher than the received commitments. The variable {\tt iO+1} is used here to address the unbalance caused by this; without it, the comparison between the sent commitments from $O$ and the received commitments of $R$ would yield an incorrect result. 



\section{Differences to DTMC}

Due to the expansion, it is now possible to choose an action to follow from a list of current possibilities; the choice can be non-deterministic, something not possible in a DTMC. The screen-shot at figure \ref{mdpPEx} shows how the simulation of an MDP model is represent in the PRISM model checker.

\begin{figure}[h!]
\centering
\includegraphics[width=180mm]{images/mdpPExample.png}
\caption{The results of manual simulation of an MDP in the PRSIM engine}
\label{mdpPEx}
\end{figure}

The screen-shot at \ref{mdpPEx} shows how the MDP style model allows for parties to choose from a list of different possible actions. Not all actions are always possible however; the conditions in the guards must be met to execute that specific action. The key visual difference between this screen shot and the one found at figure \ref{dtmcEx} is the box in the centre of the upper portion of the screen; this ``manual exploration'' box lists available actions that can be taken at that stage of the protocol. During the DTMC example, there was only ever one possible action listed in this box at a time, due to the nature of that model. Here, actions that can be selected by non-deterministic selection are listed, however if they have multiple possible outcome, as the $req$ command does, they are listed once for each possible outcome and their probability is set accordingly. The addition of all the probabilities for a particular action must equal to 1, regardless of the number of outcomes. For example, in \ref{mdpPEx}, $reqR$ is listed as two possible actions; once for each outcome, with the probability of that result coming from the logic in the TTP, which does add up to equal 1. The probabilities fulfil the $i/N$ for acceptance and $(N-i)/N$ for rejection as previously discussed.


\section{Analysis}
 
 
To assess the MDP style model, new properties had to be created. The following is a property designed to assess the likelihood of one party, R, at some point gaining the contract while the other party, O, not being able to obtain the contract ever after a specific point.


\begin{lstlisting}
Pmax=? [ F ((recdBitsR=N+1|resultR=1)&(G !(recdBitsO=N+1|resultO=1))) ]
\end{lstlisting}

The condition {\tt (recdBitsR=N+1|resultR=1)} represents the case where party $R$ can achieve the contract; if {\tt recdBitsR=N+1} is fulfilled then the party has gained the contract throught the exchanges of the gradual commitment protocol, or if {\tt resultR=1} that means the party has gained the contract by sending a successful resolve request to the TTP. \\
The condition {\tt (G !(recdBitsO=N+1|resultO=1))} is slightly more complex. The variables that express the methods gained are largely similar, the only difference being it is the party $O$ that is in question here. The addition of {\tt G !} means that this condition cannot be met at any stage of the protocol.\\
When checking this property with the model with both parties participating in a corrupt manner, the maximum probability of this occurring was 1. Figure \ref{problem1} illustrates why this is the case.

\begin{figure}[h!]
\centering
\includegraphics[width=170mm]{images/problem1.png}
\caption{A scenario with max probability of unfairness = 1}
\label{problem1}
\end{figure}

\subsection{Two Corrupt Parties}

Through various methods of interaction, it is possible for one party to never obtain a contract. For instance, it is possible for both parties to act honestly to a point where they both have the power to obtain the contract through the TTP, having $N$ commitments. It is then possible for one of the parties to contact the TTP and achieve their contract, while the other party passes up on there turn indefinitely. Whilst this isn't a type of interaction likely to take place, it is possible and leads to a high probability of the interaction finishing in an unfair state. However, if one party behaved in a non-corrupt manner, modelled by removing the ability for the party who ignores the other, in this case O, this would force the party into some form of action, and in the same set of situations, the party would either have to send the final commitment or if that's no longer an option, contact the TTP to obtain the contract. To do this, the guard at {\tt ignoreO} changed as follows:
\begin{verbatim}
[ignoreO] false -> (turnO'=0);
\end{verbatim}

The use of the {\tt false} condition means that {\tt ignoreO} cannot be executed, as the guard cannot be satisfied. 

\subsection{Introduction of the honest party}

The result of this change did give a lower maximum probability of unfairness; an experiment was carried out with $N$ ranging from 1 to 20. The results can be found in figure \ref{NM!}.

\begin{figure}[h!]
\centering
\includegraphics[width=180mm]{images/nm1.png}
\caption{The results of an experiment finding the maximum probability of unfairness}
\label{NM!}
\end{figure}

As shown here the probability here proved to be different when fairness was checked with the corrupt party changing. For a corrupt party $R$, the maximum probability was shown to be 1, whereas the maximum probability of unfairness for a corrupt party $O$ proved to be quantifiable as $(N-1)/N$. The reason for this is shown in Figure \ref{misfireO} and Figure \ref{}.

\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/dansanidiot.png}
\caption{Interaction should party O contact the TTP at the start of the protocol }
\label{misfireO}
\end{figure}

As shown in Figure \ref{misfireO} it is possible for party $O$ to create a zero resolve request and then contact the TTP in it's first turn, which will result in a rejection probability of 1. This would mean that if party $R$ did not leave the exchange and instead waited for the first commitment, modelled here as executing {\tt ignoreR}, the two parties could then execute the gradual commitment protocol as if nothing had happened. However,should the corrupt party $R$ receive it's final commitment and obtain the contract, party $R$ could then leave the exchange. Usually, party $O$ would contact the TTP in such a situation, however here this is no longer possible; party $O$ has already contacted the TTP, meaning there is no way it can get the contract through the TTP.

\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/dansanidiot.png}
\caption{Interaction should party R contact the TTP as soon as possible }
\label{misfireR}
\end{figure}

Figure FIGAAA shows what could happen should party $O$ be the party performing in a corrupt manner. 
It would be possible for party $R$ to create a resolve request after being sent the first commitment; this is in contrast to the previous example, where party $O$ could create a resolve request without requiring the other party to send a commitment. Similar problems then arise if the gradual commitment sending is resumed as normal; however the final interactions are slightly different. As party $O$ receives its penultimate commitment, it is able to create a resolve request knowing it is guaranteed to be successful. As party $O$ is behaving in a corrupt manner, it has the option of not continuing with the protocol and exiting early.

This shows a problem with the protocol; the two parties have different capabilities, despite the additions such as the zero resolve request. If one was to select a party to perform corruptly with, there is a distinct advantage to being the Responder if your aim is to obtain the contract whilst making sure the other party cannot. In the commerce example laid out in the introduction, this could mean that should one of the participants wish to swindle the other party, say the seller was dishonest, they would benefit from getting the other party to initiate the protocol and take on the role of the Originator.


%$(N-1)/N$, with an exception to this when $N$ is equal to 1. The reason for this is there was still the possibility of O to go to the TTP prematurely and be rejected with a probability $(N-1)/N$; if the party went to the TTP as soon as possible, giving the high probability of rejection, that probability would be $(N-1)/N$. The party could then, as described in \ref{misfireTTP}, continue to send commitments as normal, with party R not sending the final commitment to O, rendering the property true. This is more probable behaviour than before; a party could in theory contact the TTP prematurely if the other party took longer to send a commitment than assumed reasonable, and it is not unlikely that party R is always compelled to send the final commitment to party O, as this is the main issues the protocol looks to combat. 


%As stated prior, $N$ equalling 1 does not conform to the same maximum probability of unfairness as other states. This is because the parties in the protocol are severely limited to what they can do with only two rounds in the protocol, the number of rounds being defined as $N+1$.

\subsection{Multiple Turns Expansion} 

Examining the states reachable by the protocol, it was found that the behaviour of the model may have been restricted by the interpretation of corrupt. As it stands, one party may make one move per turn, however it is not unreasonable that a party considered corrupt wouldn't be bound to do only one operation at a time. It may be the case that they decide to send multiple commitments, or contact the TTP as well as sending a commitment. Expanding the model to accommodate corrupt parties performing an arbitrary number of actions per turn had an impact on the maximum probability of unfairness as defined above. The probability rose back to 1, at studying the states it became clear why.

\begin{figure}[h!]
\centering
\includegraphics[width=140mm]{images/sneaky.png}
\caption{Graphical representation of a corrupt party masking its actions}
\label{sneak}
\end{figure}

As shown in \ref{sneak}, if the corrupt party has the ability to perform multiple actions a turn, they can mask their interaction with the TTP. Whereas before it was the case that contacting the TTP would render the number of sent commitments to fall under suspicion, the corrupt party is now able to contact the TTP without forcing the honest party to do the same. This is unfortunate for the honest party as they are now at a further disadvantage as they are unable to guess the corrupt parties actions purely on the number of received commitments. As shown above, this can lead to a situation where the corrupt party masks its contact with the TTP by also sending a commitment. Should the honest party then respond with a commitment, it is possible for the corrupt party to refuse to send a bit and force the honest party to go to the TTP. If the dishonest party has failed to obtain the contract, this will cause the honest party to also be unsuccessful. Should the parties then continue, it is possible for a corrupt party R to not respond with the final commitment, in a manner similar to that shown in \ref{misfireTTP}. This gives a maximum probability of 1, as once this state has been achieved, there is nothing the honest party can do to gain the contract. 

\subsection{Limitations of MDPs}

The property of unbalance cannot be fully assessed using an MDP; MDP's lack the ability to pick out a strategy for an individual player. Therefore states reachable in an MDP can be reachable if parties work together to achieve that state; a feature that given the nature of the protocol is not helpful. This means that the unbalance cannot be analysed fully on an MDP style model; however the two probabilities from the property added together can be assessed, not considering the strategy of a single player. There will be states here that can be reached by the participation of the parties that would not occur if a single party was strategizing. Using the following property, unbalance of the MDP was analysed:
\begin{lstlisting}
 Pmax=? [F (recdBitsR=N+1 | resultR=1)] + Pmax=? [G!(recdBitsO=N+1 | resultO=1)]
\end{lstlisting}

The above property expressing balance does not appear too different to that of unfairness seen previously in the chapter. Unbalance is the sum of the probabilities that there is both a strategy to guarantee the corrupt player a contract, and another strategy focusing on blocking the honest adversary from achieving the contract. This means that those two separate conditions are looked at, with the results being summed. \\
Again, the first half of the property deals with the maximum probability that the corrupt party can at sometime obtained the contract, either by receiving all the desired commitments causing {\tt recdBitsR=N+1} or by successfully gaining the contract from the TTP, setting {\tt resultR=1}.\\
Like the fairness property, the second half focuses on the probability that the honest party, in this case $O$, cannot achieve the contract at any stage of the protocol. The difference here is that this is treated as a seperate entity, rather than part of the same condition.


Here, there where many states that had a probability higher than $1+1/N$. However as stated, this is most likely due to the states only reachable by cooperation of parties, something the property does not allow for. It is therefore necessary to expand the model further to accommodate single player strategies, however interesting to note that these situations are possible. As this model resembles real world interaction, these situations may arise due to a number of innocent reasons, and unbalance could be introduced by limitations of real life systems, such as a party contacting the TTP prematurely due to a delay in the arrival of a commitment being seen as a refusal to send by the other party.


It is important to note here that the probability being assessed results in the same maximum probabilities when the parties are swapped around; there is no benefit under these conditions to being the Responder as opposed to the Originator.

\chapter{Stochastic Multiplayer Games and the Third Model}

\section{Rationale}

The rationale for using an SMG style model is based in the property being assessed. The property focuses on more than the probability a state can be reached; the focus of the unbalance property is the summation of two probabilities obtained assessing the likelihood of two outcomes extending from two strategies. Having the model represent an SMG allows this type of property to be fully assessed.
This should have an effect on the probabilities mentioned in the previous section; as mentioned there, the probabilities arise due to 'unrealistic' behaviour. Using SMGs, it is possible to achieve a more realistic behaviour style out of the two parties.

\subsection{Changes to model}

Here, PRISM for Games \cite{chen2013prism} was used, as without the extensions present in this version of PRISM, it was not possible to model or analyse SMG models.

There were also changes required to turn the MDP model into an SMG model. These changes are shown below.
\begin{lstlisting}
player playerO
 partyO, [sendO], [reqO], [begin], [replyO]
endplayer

player playerR
 partyR, [sendR], [reqR], [replyR], [endR], [endTurnR]
endplayer
\end{lstlisting}

As shown, the concept of players are introduced into the models. They differ from modules, as though modules contain actions, in a non-SMG style model these actions are triggered as and when the logic for the action is fulfilled, provided it is fulfilled in every module it is featured. Here, actions are triggered by a player; there is a concept of ownership. Here, as the modules have already been modelled to each portray a party, the change is minimal. Each party is assigned a module and a list of actions that party is capable; so even though $reqO$ is featured in both the modules for the TTP and party O, here it is attributed to being the action of party O only. All actions present in the model require being attributed to a party; it is not possible to attribute an action to no party and leave it unactivated.

It is important to note that the TTP has not been declared as a player here. Despite having an action that in a real life setting would be under the control of the TTP, the replying to the request, these actions have been attributed to their respective parties in the sake of complexity. Also, the potential strategies of the TTP are not of interest to this project due to their predictability.

\subsection{Changes to property}

As the type of model is changing, it is necessary to also modify the property being assessed here. Whilst the property cannot be represented in its current form in PRISM, there are equivalent representations of such a property. Below is the property currently used. There are differences between the syntax used here and in the property described in the previous subsection, however that is intentional. The property used in the previous section was built to model a low level explenation of the property, where one party gets the contract and the other doesn't. For completeness, here the property will be featured as a direct translation from the property described in the paper. 

\begin{lstlisting}
(<<2>>Pmax=? [ F (recdBitsR=N+1|resultR=1)] + 
    <<2>>Pmax=? [ (G !(recdBitsO=N+1|resultO=1))] ) 
        > 1 + 1/N
\end{lstlisting}

The modelling of the unbalance property here is similar to the modelling of it found in the previous chapter. However, there is an addition here; the introduction of the party operator, $\ll 2 \gg$. This is the extension that allows the power of SMGs to be exploited; only strategies that party 2, in this case party $R$, can use to accomplish the conditions are included. \\
Also included here is the check that the probabilities is within the expect range, $N+1$. Any states that defy this property will be listed when the property is assessed in the PRISM for games model checker.

\section{Differences to the MDP}

The difference between the SMG model and the MDP model are subtle in comparison to the cast differences between the MDP and the DTMC models. Behaviour of the protocol model is the same, even with the introduction of parties and their strategies. This is due to the style the models have taken; it was already the case that modules represented parties and turns were treated as such. 

\begin{figure}[h!]
\centering
\includegraphics[width=160mm]{images/smgExample.png}
\caption{The results of manual simulation of an SMG in the PRSIM engine}
\label{smgEx}
\end{figure}

Figure \ref{smgEx} shows execution of the SMG model that is comparable to MDP model in \ref{mdpPEx}. These models represent the protocol with a corrupt party $R$ and honest party $O$. Note the stark similarities between the chain of execution here and with the MDP equivalent; the only difference is here the party that has executed that command is taken note of. The power of the SMG is not in what the models themselves can do, but how different properties can be assessed, as discussed later in this chapter.


\section{Anaysis}

\subsection{Comparison with the MDP}
%Performing analysis on the model with the unbalance property as above reveals that in its current state, with both parties able to act corrupt, the model built does not give the probability of unbalance that its promises. This is not surprising due to the nature of the property being assessed; as mentioned previously, it only  The model was therefore expanded to accommodate the reduced actions possible by the non-corrupt party; the honestly behaving party, in this case O, was stripped of the ability to ignore the other party. 
Performing analysis of the SMG equivalents of the models used in the previous stages of analysis yielded some interesting results. The first of which is that, when running the aforementioned property on an SMG style model with both parties acting in a corrupt way, there is a change in results when compared to the MDP equivalent. With $N$ as 4, there was a decrease in a number of states that were returned due to having a probability higher than $1+1/N$ from 1068 states with the MDP model to 439 states with the SMG model. This shows that the introduction of strategies does have an impact on which states are reachable, and therefore validates the introduction of the SMGs.

Despite this stark difference in a completely corrupt instance of the protocol, there are similarities with how the models respond. When analysing unbalance in the models that represent a protocol instance with a single corrupt party, the results are identical despite the fact only one party is contributing to this strategy, rather than both. This leads to the observation that there is perhaps no difference between a corrupt party using a strategy alone and a strategy which also includes the honest party. This is due to the autonomous way the honest party works; it does not have the freedom to make many choices and has to operate based on the situation it has been presented with. This renders the strategy non effective in this situation, however it is important as it ensures results obtained fit with what has been described in the paper.


\subsection{Findings with Strategies}

As stated, it was still possible for states to be reached where the maximum probability of the unbalance property was higher than $(1+1/ N)$. Upon further inspection of the states, there was a pattern emerging with the contacting of the Trusted Third Party; the majority of unbalanced states where ones where the honest party had contacted the TTP first. This then lead to the honest party having no safety for the remainder of the protocol, as if the corrupt party decided to stop sending commitments there was nothing the honest party could do; a troublesome issue, especially if the TTP had refused to satisfy the honest party's earlier request. It was decided that perhaps the intended sense of honesty was to just send commitments until the party is given cause to do otherwise; it could be argued that although a party was behaving within the rules when contacting the TTP, that an "honest" party would see no reason to unless they had been betrayed in their trust of the other party.

\subsubsection{Changes to Resolve Requests}

To model this new approach to honesty, more logic was added to the guard in the honest parties request command. Now, an honest party can only contact the TTP if the number of commitments they have received is a suspicious amount, and not equal to the expect amount; too many or too few commitments will fulfil this. This means the honest party cannot just contact the TTP when it wants to; there now has to be suspicion of corrupt behaviour from the other party in order to send a resolve request.\\
There was also here a change to the request logic, in that parties could now make a request if the other party has had a response from the TTP. This meant that the dishonest party could no longer mask their interaction with the TTP; the paper was unclear as to whether the TTP kept parties informed of the other party's actions. If this is not the intention, it is something that should be considered; the role of the TTP is to offer an honest impartial mediator, and it is reasonable that such a mediator would inform all parties of key information. This also means the TTP cannot be abused as a tool for achieving a corrupt goal such as the one laid out in the protocol, and described in \ref{sneak}. 


There was a further change to the modelling of the honest party in the way it handles the results from the TTP. Now that the honest party, suppose party $O$, can only contact the TTP when the other party has refused to cooperate, contacting the TTP is effectively the last thing the party can do. Once the party has received the result from the TTP, it is sensible for the party to end it's involvement in the protocol. If this was not to happen, either the protocol ends up stuck in a dead state where no parties are able to act, or if the corrupt adversary starts sending commitments again, the honest party could resume sending commitments. This latter option is harmful to the honest party as previously described, as it would possible for the corrupt adversary to gain all the bits they require then desert the exchange; with the honest party now having no way of achieving the contract. This style of interaction accounted for a large number of the states that did not satisfy the property given to PRISM, and although it is non-trivial, it is simple to justify. 

\subsubsection{Corruptness: re-defined}
It is important to note here that the definition of honesty has been changed. An honest party is now considered to be one that only sends commitments when it should, only contacts the TTP when provoked by dishonest actions by the adversary, and that should the party need to contact the TTP it will take no future participation in the protocol instance.


\subsection{Results V3}



When running the protocol with R as the dishonest party, there were still states in which the unbalance property was met with a probability greater that $1+1/N$, although the number had reduced drastically since the redefinition of corrupt. Running the model with $N$ as 4, the number of renegade states fell from 210 to only 14. Looking at these states, it was initially unclear why; all of the states were ones where up until $sentBitsO$ was $N-1$, honest interaction had been displayed by both parties. Figure \ref{finalProblem} shows how the probability is assessed.

\begin{figure}[h!]
\centering
\includegraphics[width=140mm]{images/probelmExp.png}
\caption{An explanation of how the probability of unbalance is assessed}
\label{finalProblem}
\end{figure}

%The issue here is how the property itself is presented within the paper. The property is represented as the addition of two sets of probabilities, each with their own strategy. This means that when calculating the probability, states do not have to fulfil both the conditions from the property simultaneously. As is the case here, states which can lead to the honest party gaining the contract or instead lead to the dishonest party being blocked from achieving the contract, fulfil the criteria. These states highlight the issue, being states where it is impossible to be able to go from and achieve the contract for R whilst guaranteeing O can never be satisfied. The figure below gives a literal example found when the protocol runs with $N$ as 4.

\subsubsection{Example}

\begin{figure}[h!]
\centering
\includegraphics[width=140mm]{images/problem.png}
\caption{An example problem state}
\label{problemState}
\end{figure}

The image \ref{problemState} depicts the calculation of the probability from a single state that fulfils the majority of the property, except for the probability gained from it. This is a real state found during analysis, and the key variables are as follows:
\begin{itemize}
\item sentBitsO is equal to 3, meaning that the originator has at this stage sent three commitments
\item recdBitsO is equal to 2, suggesting the originator has been sent 2 commitments
\item The variable {\tt turnO} is equal to 0, showing it is not the turn of the originator
\item sentBitsR is equal to 2, meaning that the responder has at this stage sent 2 commitments
\item recdBitsR is equal to 3, suggesting the originator has been sent a total of 3 commitments
\item The variable {\tt turnO} is equal to 1, showing it is the turn of the responder to act
\end{itemize}

All other variables, including those in the TTP, are set to 0. The fact none of the variables contained within the TTP means that no parties have attempted to contact the TTP, as does the {\tt contactX} and {\tt resultX} variables of both parties still equalling 0. As party $R$ hasn't contacted the TTP, and party $O$ has only sent one more commitment than party $R$, it can be deduced that the protocol is currently in the third round, with party $R$ yet to send their commitment for the round; it is also deducible that as no party has yet contacted the TTP, both parties have thus far behaved in an honest and non-corrupt manner.
%and in PRISM is represented as the state $(3,2,0,0,0,2,3,1,0,0,0,0,0,0,0,0)$. The first five numbers represent the values of the variables in the O module, the second five values in the R module and the final six represent the variable values present in the TTP. The state is such that both parties have acted honestly thus far; the TTP hasn't been contacted and there has been an appropriate number of commitments received by each team. It is currently party R's turn, denoted by 1 being the eighth digit in the state, and R has three commitments to the Originators two. It can be deduced that the parties have behaved honestly as even though R has been modelled to have the capacity to act in a corrupt manner, the variables in the TTP have not been changed since the start of the protocol, meaning there had been no contacting of the TTP.

The probability itself, as shown in the diagram, is actually the sum of the two probabilities featured in the property. It is not possible from here to fulfil both conditions of the property with a single strategy; this observation will be expanded on later. From this state, the corrupt party can achieve the contract with probability of 1; to do this, it would just need to act like an honest party and continue sending gradual commitments. Also, there is the possibility for the corrupt party here to refuse to send a commitment; this forces the honest party to contact the TTP for a resolution. Due to the rules of the TTP, the honest party has an $N-i/N$ probability of not achieving the contract; here, that probability is 0.5. This give an overall probability of 1.5, higher than the $1+1/N$, or 1.25, required.

\subsection{Comparison between O and R as corrupt}
It is worth noting here that when swapping the honest and dishonest parties around, there is a similar number of states that do not fulfil the protocol. Looking at the states themselves, they are the equivalents of one another, with the party often being the opposite. This is due to the strategy component; a party can only guarantee what is going to happen next if it is that parties turn.The graph shown at figure \ref{finalGraph} shows the result of two PRISM experiments performed; one experiment on the unbalance property with party $O$ as corrupt, and one with party $R$ corrupt. The ranges for $N$ here range from 2 to 30 with an interval of 1 for each value; the range would run from 1, however there is currently an issue with PRISM running experiments beginning with 1.

\begin{figure}[h!]
\centering
\includegraphics[width=140mm]{images/finalGraph.png}
\caption{Output of experiments on unbalance property for final models}
\label{finalGraph}
\end{figure}

The output of the experiment shows two things of importance; firstly, the number of states is identical when swapping the parties roles means that the culmination of efforts to keep the protocol fair for both parties is successful; there isn't an advantage for either party to try and cheat. The additional logic in the TTP for comparisons of requests combined with the ability for party $O$ to make a resolve request without having received a commitment mitigates the risk associated with having to make the first transaction in the gradual commitment protocol. The second thing the graph shows is that the actual number of rogue states is equivalent to\\

\centerline{$N\left ( \frac{N + 1}{2} \right )$}.

This is due to the states that arise; the outer $N$ is because there are rogue states for each round the protocol executes for. each is associated with the number of sent commitments by the honest party, which here will be referred to as $i$. The inner fraction, $\frac{N + 1}{2}$, is slightly more complex to explain. For each round that is executed, the number of states that go against the protocol decreases by 1, tending to zero. The number of commitments the corrupt party is able to send ranges from $i-1$ to $N-1$, with an extra state when the number of the honest party's received commitments equals the number of commitments sent by the corrupt party. This extra state is different as all the other states are ones where it is the corrupt parties turn to act; in the extra state, it is the honest party's turn.

The reason for this is the number of commitments a corrupt party can still send is ever decreasing as the protocol continues; the majority of states represent the system after the corrupt party has willingly sent too many commitments, and as the protocol runs there are simply less ``extra'' commitments that can be sent.

\subsection{Observation of Strategy and Honesty}

A pattern also emerged regarding the parties who participated in the strategy building. If the strategy is built collaboratively by both parties, as in the MDP model, the number of states that disagreed with the property was the same as the number of states when only the corrupt party had a strategy. This is likely due to the almost autonomous interaction of the honest party; if a party behaves in an honest manner, their behaviour is predictable, yielding the same result consistently when tried under similar conditions. The same cannot be said of the corrupt party, due to the non-deterministic nature of their interaction.

\section{My Property}

The results on the face of it seem to suggest that there is a problem with the unbalance property. The analysis suggests it fails to deliver on the probabilities highlighted in the paper, and therefore does not have the benefits it's designed to bring. However, I don't think there's an issue with the model, I feel the issue is rooted in the description of the property. Again the argument goes back to semantics; as before it was difficult to assess what was considered corrupt, now there is questionable results being affected by what is considered unbalanced. 

The unbalance property looks at the probabilities of two separate options and adds them together, as shown in figure \ref{finalProblem}. It is my recommendation that the protocol be amended in the following way;\\

\centerline{$ G{_{Pr}},q_{Pr}^{0}\models  \ll A, T, B, X, S \gg ^{>0} \diamondsuit (\ll A, S, B \gg^{\ge Pa} \diamondsuit \varphi{_{abr}} \wedge \varphi{_{res}}) $}

The difference here is that there is a single strategy to achieve one outcome, rather than one for obtaining the contract and one for stopping the other party. This property would be fulfilled if there was a single strategy that both guaranteed the corrupt party the contract whilst guaranteeing that at no state can the honest party achieve the contract. This is essentially the same property as used during the analysis of the MDP model, however players and strategies can now be added as this is a property for an SMG style model. The property inside PRISM now has the following structure:
\begin{lstlisting}
<<2>> Pmax=? [FfG ((recdBitsR=N+1 | resultR=1)&!(recdBitsO=N+1 | resultO=1))]
\end{lstlisting}
This property lists the states where the Responder has the capability to use a strategy that would both see them obtain the contract and guarantee the other party can not finish successfully, as well as the maximum probability of this happening for each state. Although there are states which technically fulfil the majority of the criteria, all of the ones found have a probability of zero. This is BRILLIANT, as it means that the protocol does not allow one party to have a real advantage over the other party, and either both parties are equally successful at obtaining the contract. 



\chapter{Conclusion}

Models were constructed allowing the protocol described to be analysed, primarily to ensure the property it promises holds. This took a number of models and iterations, but was comprised of three main sections; a DTMC modelling the Gradual Commitment Protocol, an MDP designed to model the full interaction of the system, and an SMG adaptation of the MDP, allowign the model to be assessed with the necessary addition of strategies.

It has been shown that when considering strategies, there is no difference between two parties creating a strategy together, and one party creating a strategy against a predictable opponent. These two approaches yielded the same results when being analysed against the unbalance property.

The protocol also has been shown to provide equal opportunities for both parties involved in terms of unbalance; there is no advantage to being the originator or responder with respect to being balanced as described in the property. This is greatly to the protocol's credit; the paper acknowledged the importance of ensuring there was no advantage to being a particular party, and steps were successfully taken to ensure that this was the case. This is done by careful consideration with the regards to the logic applied by the TTP and the differences between the originator and responder resolution requests.

The protocol has also been shown to not posses the properties advertised. Whilst it does allow two participants to swap contracts, fulfilling the base requirements of a contract signing protocol, it lacks the benefits the protocol needs to be of any use. Whilst the design of the TTP and the gradual commitment protocol eliminates a large number of situations considered to be unbalanced from arising, it does not provide the advertised property. As such, the protocol does not improve on other, tested, CSPs, such as Rabins, which also offers a similar maximum level of unbalance with a better definition of unbalance.\\
The authors of the protocol state that the property holds, meaning either there is a problem with their arguments featured in the proof, or the lack of clarity has led to a difference of opinion on components of the protocol and the model thusly does not model the author's interpretation of the protocol.
There is a similar lack of clarity in the proof itself; whilst full analysis of this is outside the scope of this project, it has been noted that assumptions have been made which have no mathematical reasoning provided.


\section{Future Work}


Further work should also be done on how the protocol is presented. Due to a lack of clarity in the paper, assumptions have been made on what is meant by corrupt and honest. Therefore it is possible that the results presented here do not accurately reflect the author's intended protocol; however, it should be more definitive when defining concepts it later then relies on in the property. The property description should also be re-examined, as it has been shown here it is not as intended. The property should also be made more human readable; in it's original form, it is highly complex, and this is an issue. It can be expressed in simpler terms, so it should be - i think that's Occam's Razor. Even if it isn't, I have to find a valid way to express this: it was needlessly complicated and made understanding the protocol very hard. I think maybe that's why no-ones found these problems before, they've taken one look and run away.

Should any the aforementioned changes take place, the work done here should be revisited. Having complete definitions for some of the core concepts may prove the protocol more or less effective. Any changes in the model would be of relative ease to make, and may make all the difference in the output of the results. The same is true of any revisions to the explanation of the property; any change there would warrent no change in the model itself, only in a new property.

Work should also be done on expanding the protocol to accommodate multiple parties. The approach taken to ensure fairness to the originator may prove usable in a system with multiple participants.




%%%%%%%%%%%%%%%%
%              %
%  APPENDICES  %
%              %
%%%%%%%%%%%%%%%%
\begin{appendices}

\chapter{Running the Programs}
An example of running from the command line is as follows:
\begin{verbatim}
      > java MaxClique BBMC1 brock200_1.clq 14400
\end{verbatim}
This will apply $BBMC$ with $style = 1$ to the first brock200 DIMACS instance allowing 14400 seconds of cpu time.

\chapter{Generating Random Graphs}
\label{sec:randomGraph}
We generate Erd\'{o}s-R\"{e}nyi random graphs $G(n,p)$ where $n$ is the number of vertices and
each edge is included in the graph with probability $p$ independent from every other edge. It produces
a random graph in DIMACS format with vertices numbered 1 to $n$ inclusive. It can be run from the command line as follows to produce 
a clq file
\begin{verbatim}
      > java RandomGraph 100 0.9 > 100-90-00.clq
\end{verbatim}
\end{appendices}

%%%%%%%%%%%%%%%%%%%%
%   BIBLIOGRAPHY   %
%%%%%%%%%%%%%%%%%%%%
\nocite{*}
\bibliographystyle{plain}
\bibliography{bib}

\end{document}
